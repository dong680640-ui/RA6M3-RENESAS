#include "hal_data.h"
#include "string.h"

#include <Setting.h>
#include <FND.h>
#include <Run_DC.h>
#include <Run_Speaker.h>
#include <Run_Servo.h>
#include <CAN.h>
#include <Confirm.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

uint8_t floor_state[4] = {0, 0, 0, 0}; //각 층의 버튼이 눌렸는지 여부
uint8_t Elevator_state = 0; //엘리베이터 동작 여부
uint8_t Current_floor = 0; //현재 층
uint8_t Goal_floor = 0; //목표 층
uint8_t direction = 0; //엘리베이터 동작 방향, 0:STOP, 1:UP, 2:DOWN

volatile uint8_t count_200ms = 0; //200ms count

//FND 변수
uint8_t print_data[4] = {0xFE, 0xCF, 0xCF, 0xFE}; //현재 출력, 기본 출력은 '-11-'
uint8_t number[10] = {0x81, 0xCF, 0x92, 0x86, 0xCC, 0xA4, 0xA0, 0x8D, 0x80, 0X84}; //0~9
uint8_t rotate[7] = {0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFE}; //엘리베이터 동작 시 rotate 출력 + 엘리베이터 정지 시 출력

//CAN 변수
can_frame_t g_can_tx_frame;
can_frame_t g_can_rx_frame;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    Initial_Setting(&g_can_rx_frame);
    while(true) {
        Confirm_state(floor_state, &Elevator_state); //엘리베이터 동작 여부 확인
        //엘리베이터 동작
        if (Elevator_state == 1) {
            uint8_t Goal_past = Goal_floor; //과거 목표 층
            Confirm_floor(direction, Current_floor, &Goal_floor, floor_state); //목표 층 업데이트
            if (Goal_past != Goal_floor) { //현재와 비교, 다르면
                Send_to_PC(1, Goal_floor + 1); //CAN통신
                print_data[2] = number[Goal_floor + 1]; //FND 출력 업데이트
            }
            Confirm_direction(Elevator_state, &direction, Current_floor, Goal_floor); //엘리베이터 방향 업데이트
            //목표 층에 도착
            if (Current_floor == Goal_floor) {
                Stop_DC(); //DC모터 OFF
                Send_to_PC(2, Current_floor + 1); //CAN통신

                print_data[0] = rotate[6]; //FND 출력 업데이트
                print_data[1] = number[Current_floor + 1];
                print_data[3] = rotate[6];

                Run_Speaker(); //알림음 출력

                count_200ms = 0; //1초 기다림
                while (count_200ms < 5)
                    FND_Print_Data(print_data);

                Send_to_PC(3, 0); //CAN통신
                Run_Servo(0); //문 열림

                count_200ms = 0; //2초 기다림
                while (count_200ms < 10)
                    FND_Print_Data(print_data);

                Send_to_PC(4, 0); //CAN통신
                Run_Servo(1); //문 닫힘

                count_200ms = 0; //1초 기다림
                while (count_200ms < 5)
                    FND_Print_Data(print_data);

                floor_state[Current_floor] = 0; //눌려있던 버튼 꺼짐
                R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[Current_floor], BSP_IO_LEVEL_HIGH); //LED OFF
            }
            //목표 층으로 가는 중, 현재 층 업데이트
            else {
                Run_DC(direction); //DC모터 ON

                count_200ms = 0; //3초 기다림
                while (count_200ms < 15)
                    FND_Print_Data(print_data);

                if (direction == 1) //올라가는 중이라면
                    Current_floor++; //현재 층 +1
                else if (direction == 2) //내려가는 중이라면
                    Current_floor--; //현재 층 -1
                print_data[1] = number[Current_floor + 1]; //FND 출력 업데이트
            }
        }
        //엘리베이터 정지
        else
            FND_Print_Data(print_data);
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

//Interrupt 함수
//Switch Interrupt
void R_IRQ_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case 11: { //1층 눌림
            floor_state[0] = 1; //변수 업데이트
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[0], BSP_IO_LEVEL_LOW); //LED ON
            break;
        }
        case 12: { //2층 눌림
            floor_state[1] = 1;
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[1], BSP_IO_LEVEL_LOW);
            break;
        }
        case 13: { //3층 눌림
            floor_state[2] = 1;
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[2], BSP_IO_LEVEL_LOW);
            break;
        }
        case 14: { //4층 눌림
            floor_state[3] = 1;
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[3], BSP_IO_LEVEL_LOW);
            break;
        }
    }
    uint8_t Goal_past = Goal_floor; //과거 목표 층
    Confirm_floor(direction, Current_floor, &Goal_floor, floor_state); //목표 층 업데이트

    if (Goal_past != Goal_floor) { //과거와 비교, 다르면
        Send_to_PC(1, Goal_floor + 1); //CAN통신
        print_data[2] = number[Goal_floor + 1]; //FND 출력 업데이트
        //방향이 같은 경우에만 interrupt 즉시 업데이트함
    }
}
//AGT Interrupt
void R_AGT0_Interrupt(timer_callback_args_t *p_args) //200ms 주기
{
    FSP_PARAMETER_NOT_USED(p_args);
    count_200ms++; //count 업데이트
    if (Current_floor != Goal_floor) { //엘리베이터 움직이는 중
        print_data[0] = rotate[5 - (count_200ms % 6)]; //1번 FND rotate
        print_data[3] = rotate[(count_200ms + 1) % 6]; //4번 FND rotate(1번과 반대 방향)
    }
}
//CAN 콜백 함수
void can_callback(can_callback_args_t *p_args)
{
    switch(p_args->event)
    {
        case CAN_EVENT_RX_COMPLETE:
            g_can_rx_frame = p_args->frame;
            memset(&(p_args->frame), 0, sizeof(can_frame_t));
            break;
        default:
            break;
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
