#include "hal_data.h"
#include <Library.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void AD_Convert();
void Potentiometer_Read();
void Thermal_Sensor_Read();
void Cds_Sensor_Read();
int ASCIItoHEX(uint8_t ASCII);
void process_uart_message(uint8_t *message, uint8_t max_index);
FSP_CPP_FOOTER

//FND 변수
uint8_t print_data[4] = {0x81, 0x81, 0x81, 0x81}; //기본 출력은 '0000'
uint8_t number[16] = {0x81, 0xCF, 0x92, 0x86, 0xCC, 0xA4, 0xA0, 0x8D, 0x80, 0X84, //0~9
                      0x88, 0xE0, 0xB1, 0xC2, 0xB0, 0xB8}; //A~F

//LED 변수
uint8_t LED1_State = 0; //0이면 OFF, 1이면 ON
uint8_t LED2_State = 0;
uint8_t LED3_State = 0;

//Count 변수
int operating_count = 0;
int operating_count_state = 0;

//DC motor 변수
uint32_t Timer_Period = 0x3A980; // 2[ms] Duty Cycle (500[Hz])
uint8_t DC_direction = 1; //0이면 CW, 1이면 CCW
uint8_t DC_velocity = 1; //0이면 low, 1이면 high

//ADC 변수
uint8_t ADC_state = 0; //0이면 OFF, 1이면 ON
uint8_t ADC_mode = 0;
const float ADC_CONST = (float)(3.3/4096);
int Ra_value; //Variable Resistor
uint16_t temperature; //Thermal Sensor
uint16_t cds_data; //Cds Sensor

//Sound 변수
extern unsigned char rawData1[192480]; //Sound 1
extern unsigned char rawData2[190176]; //Sound 2

//UART 변수
uint8_t received_message[32];
uint8_t index = 0; //received_message의 주소

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    Initial_Setting();
    R_GPT3->GTPR = Timer_Period - 1; //GPT Setting (Timer_Period 변수 포함)
    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.8); //GPT Setting (Timer_Period 변수 포함)
    R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);

    while(true) {
        FND_Print_Data(print_data);
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

//Interrupt 함수
//Switch Interrupt
void R_IRQ_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case 11: { //GUI count++
            uint8_t message[7] = {0x02, 0x32, 0x31, 0x30, 0x31, 0x31, 0x03};
            R_SCI_UART_Write(&g_uart0_ctrl, message, sizeof(message));
            break;
        }
        case 12: { //ADC mode 바꿈(0~2)
            if (ADC_mode < 2)
                ADC_mode++;
            else
                ADC_mode = 0;
            print_data[2] = number[ADC_mode]; //3번 FND에 출력
            break;
        }
        case 13: { //3번 LED toggle
            LED3_State ^= 1;
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[2], (LED3_State == 1 ? BSP_IO_LEVEL_LOW : BSP_IO_LEVEL_HIGH));
            break;
        }
        case 14: { //1번, 2번 FND 초기화 = count 초기화
            operating_count = 0;
            break;
        }
    }
}
//AGT Interrupt
void R_AGT0_Interrupt(timer_callback_args_t *p_args) //500ms 주기
{
    FSP_PARAMETER_NOT_USED(p_args);
    AD_Convert(); //500ms마다 ADC 함수 동작
    if (operating_count_state == 1) { //1초마다 count 동작
        print_data[0] = number[operating_count / 10]; //일의 자리
        print_data[1] = number[operating_count % 10]; //십의 자리
        operating_count = operating_count + 1;
        if (operating_count > 99) //99를 초과하면 초기화
            operating_count = 0;
        operating_count_state = 0;
    }
    else
        operating_count_state = 1;
}

//ADC 함수
void AD_Convert()
{
    if (ADC_state == 1) { //ADC가 ON일 때만 동작
        uint8_t message[8] = {0x02, 0x35, 0x31, 0x31, 0x32, 0x00, 0x00, 0x03};
        if (ADC_mode == 0) { //Variable Resistor
            ADC0_Setting();
            ADC0_Read_and_Convert();
            Potentiometer_Read();
            message[5] = 0x30;
            message[6] = (uint8_t)Ra_value;
            R_SCI_UART_Write(&g_uart0_ctrl, message, sizeof(message));
        }
        else if (ADC_mode == 1) { //Thermal Sensor
            ADC1_Setting();
            ADC1_Read_and_Convert();
            Thermal_Sensor_Read();
            message[5] = 0x31;
            message[6] = (uint8_t)temperature;
            R_SCI_UART_Write(&g_uart0_ctrl, message, sizeof(message));
        }
        else if (ADC_mode == 2) { //Cds Sensor
            ADC0_Setting();
            ADC0_Read_and_Convert();
            Cds_Sensor_Read();
            message[5] = 0x32;
            if (cds_data >= 400) //어두운 경우
                message[6] = 0x30;
            else                // 밝은 경우
                message[6] = 0x31;
            R_SCI_UART_Write(&g_uart0_ctrl, message, sizeof(message));
        }
    }
}
//Variable Resistor
void Potentiometer_Read()
{
    uint16_t potentiometer_mV, potentiometer_Ra, potentiometer_Rb;
    uint16_t ch0_adc_result;

    R_ADC_Read(&g_adc0_ctrl, ADC_CHANNEL_0, &ch0_adc_result);
    potentiometer_mV = (uint16_t)(ch0_adc_result * ADC_CONST * 1000);
    potentiometer_Rb = (uint16_t)(potentiometer_mV * 3.0303);
    potentiometer_Ra = (uint16_t)(10000 - potentiometer_Rb);

    Ra_value = (potentiometer_Ra * 100 + 5000) / 10000; //계산 + 반올림 처리
}
//Thermal Sensor
void Thermal_Sensor_Read()
{
    uint16_t temperature_mV = 0;
    uint16_t ch1_adc_result;

    R_ADC_Read(&g_adc1_ctrl, ADC_CHANNEL_1, &ch1_adc_result);
    temperature_mV = (uint16_t)(ch1_adc_result * ADC_CONST * 1000);

    if (temperature_mV >= 500)
        temperature = (uint16_t)((temperature_mV - 500 + 5) / 10); //계산 + 반올림 처리
    else
        temperature = (uint16_t)((500 - temperature_mV + 5) / 10); //계산 + 반올림 처리
}
//Cds Sensor
void Cds_Sensor_Read()
{
    uint16_t ch2_adc_result;

    R_ADC_Read(&g_adc0_ctrl, ADC_CHANNEL_2, &ch2_adc_result);
    cds_data = ch2_adc_result;
}

//ASCII code를 한 자리 16진수로 변환
int ASCIItoHEX(uint8_t ASCII) {
    if (ASCII >= '0' && ASCII <= '9') //0~9
        return ASCII - '0';
    else if (ASCII >= 'A' && ASCII <= 'F') //A~F
        return ASCII - 0x37;
    else //다른 입력
        return -1;
}

//UART message 처리 함수
void process_uart_message(uint8_t *message, uint8_t max_index) {
    // STX 또는 ETX가 적절하지 않은 경우
    if (message[0] != STX || message[max_index] != ETX)
        return;
    //LED
    if (message[1] == 0x30 && message[2] == 0x30 && message[3] == 0x30 && message[4] == 0x31) {
        switch (message[5]) {
            case 0x30: { // 1번 LED toggle
                LED1_State ^= 1;
                R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[0], (LED1_State == 1 ? BSP_IO_LEVEL_LOW : BSP_IO_LEVEL_HIGH));
                break;
            }
            case 0x31: { // 2번 LED toggle
                LED2_State ^= 1;
                R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[1], (LED2_State == 1 ? BSP_IO_LEVEL_LOW : BSP_IO_LEVEL_HIGH));
                break;
            }
            default:
                break;
        }
    }
    //FND
    else if (message[1] == 0x31 && message[2] == 0x30) {
        switch (message[3]) {
            case 0x30: { // 한 자리 10진수
                if (message[4] == 0x31) {
                    int print_number = ASCIItoHEX(message[5]);
                    if (print_number == -1) //적절하지 않은 입력
                        print_data[3] = 0xFF;
                    else //적절한 입력
                        print_data[3] = number[print_number];
                }
                break;
            }
            case 0x31: { // 한 자리 16진수
                if (message[4] == 0x31) {
                    int print_number = ASCIItoHEX(message[5]);
                    if (print_number == -1) //적절하지 않은 입력
                        print_data[3] = 0xFF;
                    else //적절한 입력
                        print_data[3] = number[print_number];
                }
                break;
            }
            case 0x32: { // 네 자리 2진수
                if (message[4] == 0x34) {
                    int print_number = 0b0000;
                    for (int j = 0; j < 4; j++) {
                        uint8_t num; //네 자리 출력 중 한 자리
                        if (message[j + 5] == 0x30)
                            num = 0b0;
                        else if (message[j + 5] == 0x31)
                            num = 0b1;
                        else //적절하지 않은 입력
                            num = 16; //범위를 벗어나도록
                        num = num << (3 - j); //자리에 맞게 shift
                        print_number = print_number | num;
                    }
                    if (print_number >= 0b0000 && print_number <= 0b1111) //적절한 입력
                        print_data[3] = number[print_number];
                    else //적절하지 않은 입력
                        print_data[3] = 0xFF;
                }
                break;
            }
            default:
                break;
        }
    }
    //DC motor
    else if (message[1] == 0x34 && message[2] == 0x30 && message[4] == 0x30) {
        switch(message[3]) {
            case 0x30: { //ON, 첫 ON일 때는 CCW, 속도 high
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_00, BSP_IO_LEVEL_HIGH);
                break;
            }
            case 0x31: { //OFF
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_00, BSP_IO_LEVEL_LOW);
                break;
            }
            case 0x32: { //속도 high
                if (DC_direction == 0) //CW
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.2);
                else //CCW
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.8);
                DC_velocity = 1;
                break;
            }
            case 0x33: { //속도 low
                if (DC_direction == 0) //CW
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.6);
                else //CCW
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.4);
                DC_velocity = 0;
                break;
            }
            case 0x34: { //CW
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_01, BSP_IO_LEVEL_HIGH);
                if (DC_velocity == 1) //속도 high
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.2);
                else //속도 low
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.6);
                DC_direction = 0;
                break;
            }
            case 0x35: { //CCW
                R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_09_PIN_01, BSP_IO_LEVEL_LOW);
                if (DC_velocity == 1) //속도 high
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.8);
                else //속도 low
                    R_GPT3->GTCCR[0] = (uint32_t)(Timer_Period * 0.4);
                DC_direction = 1;
                break;
            }
            default:
                break;
        }
    }
    //A/D Converting
    else if (message[1] == 0x35) {
        if (message[2] == 0x30 && message[3] == 0x30 && message[4] == 0x31) {
            if (message[5] == 0x30) //OFF
                ADC_state = 0;
            else if (message[5] == 0x31) //ON
                ADC_state = 1;
        }
    }
    //D/A Converting
    else if (message[1] == 0x36 && message[2] == 0x30 && message[3] == 0x30 && message[4] == 0x31) {
        IRQ_Disable(); //Switch Interrupt 차단
        R_SCI_UART_Close(&g_uart0_ctrl); //UART 차단

        uint16_t value;
        if (message[5] == 0x31) { //Sound 1
            for (uint32_t i = 0; i < sizeof(rawData1); i += 2) {
                value = (uint16_t)(rawData1[i] | (rawData1[i + 1] << 8));
                R_DAC_Write(&g_dac0_ctrl, value);
                R_BSP_SoftwareDelay(20, BSP_DELAY_UNITS_MICROSECONDS);
            }
        }
        else if (message[5] == 0x32) { //Sound 2
            for (uint32_t i = 0; i < sizeof(rawData2); i += 2) {
                value = (uint16_t)(rawData2[i] | rawData2[i + 1] << 8);
                R_DAC_Write(&g_dac0_ctrl, value);
                R_BSP_SoftwareDelay(20, BSP_DELAY_UNITS_MICROSECONDS);
            }
        }

        IRQ_Enable(); //Switch Interrupt 활성화
        R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg); //UART 활성화
    }
}
//UART 콜백 함수
void user_uart_callback(uart_callback_args_t *p_args) {
    if (p_args->event == UART_EVENT_RX_CHAR) {
        uint8_t received_data = (uint8_t)p_args->data; //수신 프로토콜 받기
        if (received_data != 0x03) //ETX 외 다른 입력
            received_message[index++] = received_data;
        else { //ETX 입력
            received_message[index] = received_data;
            process_uart_message(received_message, index); //최종 프로토콜 처리, 이때 index는 max_index
            index = 0; //index 초기화
        }
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
