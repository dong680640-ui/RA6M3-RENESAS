#include "hal_data.h"
#include "stdlib.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void IRQ_Initial_Setting();
void IRQ_Enable();
void IRQ_Disable();
void Initial_Setting();
void LED_Reset();
void R_AGT1_Setting();
void R_GPT_Setting();
void R_GPT0_Setting();
void R_GPIO_Setting();
void R_AGT_Callback();
FSP_CPP_FOOTER

#define SEGMENT_INDEX               8
#define DIGIT_INDEX                 4
#define LED_INDEX                   4

#define AGT_ACCE_PERIOD             5
#define AGT_DECE_PERIOD             4
#define DUTY_RATE_UNIT              5

#define IO_PCNTR1_MASK              0x00010003

#define ANGLE_UNIT                  30
#define MAX_SERVO_DEGREE            180
#define AGT_SERVO_PERIOD            (MAX_SERVO_DEGREE / ANGLE_UNIT)

volatile const uint8_t state_mask = 0x01;
volatile uint8_t led_state = 0;
volatile const uint32_t Timer_Period_20ms = 0x249F00; // 20[ms] Duty Cycle (50[Hz])


typedef enum _servo_state {
    SERVO_ROTATE_RIGHT = 0,
    SERVO_ROTATE_LEFT
} servo_state;

servo_state motor_state = SERVO_ROTATE_RIGHT;

typedef struct _operation_state {
    volatile uint8_t task_mode_11;
    volatile uint8_t task_mode_12;
    volatile uint8_t task_mode_13;
    volatile uint8_t task_mode_14;
} operation_state;

volatile operation_state state;
volatile servo_state rotate_mode;

static const bsp_io_port_pin_t led_pin[4] = {
                                BSP_IO_PORT_10_PIN_08,
                                BSP_IO_PORT_10_PIN_09,
                                BSP_IO_PORT_10_PIN_10,
                                BSP_IO_PORT_11_PIN_00
};

uint16_t Timer_Period_200ms = 820;
uint32_t servo_angle = 0;


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    Initial_Setting();
    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    while (true);
    ///////////////////////////////////////////////////////////////////////////


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void Initial_Setting()
{
    state.task_mode_14 = 0;
    R_GPIO_Setting();
    IRQ_Initial_Setting();
    R_AGT1_Setting();
    R_GPT_Setting();
}

void R_GPIO_Setting()
{
    R_PORT9->PCNTR1 |= IO_PCNTR1_MASK;

    R_PORT10->PCNTR1_b.PDR |= 0x0700;
    R_PORT11->PCNTR1 |= 0x0001;

    LED_Reset();
}

void IRQ_Initial_Setting()
{
    // Interrupt ICU Setting
    R_ICU_ExternalIrqOpen(&g_external_irq14_ctrl, &g_external_irq14_cfg); // enable switch 4
    R_AGT_Open(&g_timer1_ctrl, &g_timer1_cfg);                             // enable AGT 1
    IRQ_Enable();
}
void IRQ_Enable()
{
    // Interrupt Set Enable Register Setting (Enable)
    R_ICU_ExternalIrqEnable(&g_external_irq14_ctrl);

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    // Use register to enable only (switch 4) interrupt
    NVIC->ISER[0] |= 1 << 0;
    R_ICU->IELSR_b[0].IELS = (uint32_t)0x0F; // ICU Event Link Select (Refer to the Table 14.4) (Port_IRQ14)
    R_PMISC->PWPR_b.B0WI = (uint8_t)0U; // PFSWE bit Write Protection Disable
    R_PMISC->PWPR_b.PFSWE = (uint8_t)1U; // PmnPFS Register Write Protection Disable
    R_PFS->PORT[0].PIN[10].PmnPFS_HA_b.ASEL = (uint16_t)0U; // Port m/n Pin Function Select: Analog Input
    R_PFS->PORT[0].PIN[10].PmnPFS_HA_b.ISEL = (uint16_t)1U; // Port m/n Pin Function Select: IRQ Input Mode
    ///////////////////////////////////////////////////////////////////////////
}
void IRQ_Disable()
{
    // Interrupt Set Disable Register Setting (Disable)

    R_ICU_ExternalIrqDisable(&g_external_irq14_ctrl);
}

void R_AGT1_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD2 = 0U; // AGT1 Module Stop State Cancel

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////

    R_AGT1->AGTMR1 |= 0x41; // AGT1 Mode Register 1 Setting
    R_AGT1->AGTMR2 = 0x03; // AGT1 Mode Register 2 Setting
    R_AGT1->AGT = Timer_Period_200ms;

    R_AGT_Start(&g_timer1_ctrl);
    ///////////////////////////////////////////////////////////////////////////
}
void R_AGT_Callback(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    // Use register to enable AGT1 interrupt
    if (led_state == 1)
    {
        if (servo_angle == 0) //방향 설정
            motor_state = SERVO_ROTATE_RIGHT;
        else if (servo_angle == 180)
            motor_state = SERVO_ROTATE_LEFT;

        if (motor_state == SERVO_ROTATE_RIGHT) //각도 설정
            servo_angle += ANGLE_UNIT;
        else if (motor_state == SERVO_ROTATE_LEFT)
            servo_angle -= ANGLE_UNIT;

        R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_20ms * (0.03 + 0.09 / 180 * servo_angle));
    }

    if (motor_state == SERVO_ROTATE_LEFT && servo_angle == 0) // 되돌아오면 정지
    {
        LED_Reset();
        led_state = 0;
    }
    ///////////////////////////////////////////////////////////////////////////

}

void R_GPT_Setting()
{
    R_MSTP->MSTPCRD_b.MSTPD5 = 0U; // GPT32EHx (x=0 to 3) Module Stop State Cancel

    R_PMISC->PWPR_b.B0WI = (uint8_t)0U; // PFSWE Bit Write Protection Disable
    R_PMISC->PWPR_b.PFSWE = (uint8_t)1U; // PmnPFS Register Write Protection Disable

    R_PFS->PORT[4].PIN[15].PmnPFS_b.PMR = 1U; // GTIOC0A Pin Peripheral Function Enable
    R_PFS->PORT[4].PIN[15].PmnPFS_b.PSEL = 3U; // Port m/n Pin Function Select: GTIOC0A (GPT0 PWM Output)

    R_GPT0_Setting();
}
void R_GPT0_Setting() // Servo Motor PWM Generator
{
    R_GPT0->GTCR_b.MD = 0U; // GPT32EH0 Count Mode Setting (Saw-wave PWM Mode)
    R_GPT0->GTCR_b.TPCS = 0U; // GPT32EH0 Clock Source Prescale Setting (PCLKD/1)

    R_GPT0->GTPR = Timer_Period_20ms - 1; // GPT32EH0 Counting Maximum Cycle Setting
    R_GPT0->GTCNT = 0; // GPT32EH0 Counter Initial Value Setting

    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    R_GPT0->GTIOR_b.GTIOA = 9U; // Compare Matching Output Control Setting
    R_GPT0->GTIOR_b.OAE = 1U; // GPIOCA Output Pin Enable

    R_GPT0->GTCCR[0] = (uint32_t)(Timer_Period_200ms * 0.03); // GTCCR Initial Setting (Angle = 0[degree])
    R_GPT0->GTCR_b.CST = 1U;
    ///////////////////////////////////////////////////////////////////////////
}

void LED_Reset()
{
    uint8_t idx = 0;

    /* LED Initialization */
    for (idx = 0; idx < LED_INDEX; idx++)
        R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[idx], BSP_IO_LEVEL_HIGH);
}

void R_IRQ14_ISR(external_irq_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED (p_args);
    ////////////// YOU MUST EDIT ONLY HERE ABOUT Advanced Assignment ///////////////
    IRQ_Disable(); //다른 Interrupt 차단
    R_ICU->IELSR_b[0].IR = (uint32_t)0U;
    R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[3], BSP_IO_LEVEL_LOW);
    led_state = 1;
    while (true)// 정지할 때까지 해당 Interrupt 동작
    {
        if (led_state == 0)
            break;
    }
    IRQ_Enable();
    ///////////////////////////////////////////////////////////////////////////
}




/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
