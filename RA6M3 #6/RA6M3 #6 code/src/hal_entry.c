#include "hal_data.h"
#include "string.h"
#include "stdlib.h"
#include "vocabulary.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void user_uart_write(const char *msg, uint32_t const bytes);
void Count_Separate(int count_value);
void R_FND_Reset();
void R_FND_Print_Data(uint8_t *string);
void R_FND_Display_Data(uint8_t digit, uint8_t data);

FSP_CPP_FOOTER

#define STX                  0x02
#define ETX                  0x03
#define CARRIAGE_RETURN      0x0D
#define LINE_FEED            0x0A
#define Backspace            0x08

#define MESSAGE_MAX_SIZE     50

char                         msg_data[MESSAGE_MAX_SIZE] = {0};
char                         tail[2] = {CARRIAGE_RETURN, LINE_FEED};

volatile uint8_t             msg_idx = 0;
char msg_arr[MESSAGE_MAX_SIZE];

#define SEGMENT_INDEX         8
#define DIGIT_INDEX           4

#define PODR_INDEX_HIGH       7
#define PODR_INDEX_LOW        4
#define PODR_DIGIT_MASK       0x01E0
#define PODR_HIGH_MASK        0x7800
#define PODR_LOW_MASK         0x00F0
#define PODR_PIN_MASK         PODR_HIGH_MASK | PODR_LOW_MASK

uint8_t number[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xD8, 0x80, 0x90};
uint8_t print_data[4] = {0xC0, 0xC0, 0xC0, 0xC0};

char voca_now[50];
char voca_answer[50];

volatile int quiz_count;
volatile int correct_count;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    const char message[] = "Setting is complete.";
    
    R_ICU_ExternalIrqOpen(&g_external_irq11_ctrl, &g_external_irq11_cfg);
    R_ICU_ExternalIrqEnable(&g_external_irq11_ctrl);

    R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    user_uart_write(message, strlen(message));

    R_FND_Reset();

    /* TODO: add your own code here */
    int random_index = rand() % 50;
    strcpy(voca_now, voca[random_index]);
    user_uart_write(voca_now, strlen(voca_now));

    while(true)
    {
        Count_Separate(quiz_count*100 + correct_count);
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void user_uart_write(const char *msg, uint32_t const bytes)
{
    char *string = (char*)calloc(1, sizeof(char) * MESSAGE_MAX_SIZE);

    strcpy(string, msg);
    strcat(string, tail);

    R_SCI_UART_Write(&g_uart0_ctrl, (unsigned char*)string, bytes + 2);
    free(string);
}

void R_IRQ11_Interrupt(external_irq_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    R_ICU->IELSR_b[0].IR = (uint32_t)0U;
	/* TODO: add your own code here */
    quiz_count = 0;
    correct_count = 0;
    R_FND_Reset();
}

void user_uart_callback(uart_callback_args_t *p_args)
{
    if(p_args->event == UART_EVENT_RX_CHAR) // If SDR (Serial Data Register) is charged, this event (UART_EVENT_RX_CHAR) is occurred.
    {
        switch(p_args->data)
        {
            case CARRIAGE_RETURN:
                break;
            case LINE_FEED:
                /* TODO: add your own code here */
                // NULL
                msg_data[msg_idx] = '\0';

                // 정답 확인 및 변수 업데이트
                if (strcmp(msg_data, voca_now) == 0) {
                    correct_count++;
                }
                quiz_count++;

                // 다음 문제 출제
                int random_index = rand() % 50;
                strcpy(voca_now, voca[random_index]);
                user_uart_write(voca_now, strlen(voca_now));

                // 입력 초기화
                msg_idx = 0;
                memset(msg_data, 0, sizeof(msg_data));
                break;
            case Backspace:
                /* TODO: add your own code here */
                if (msg_idx > 0)
                {
                    msg_idx--;
                    msg_data[msg_idx] = '\0';
                }
                break;
            default:
                msg_data[msg_idx++] = (char)p_args->data; // If Receive data Register is charged, take some data in byte.
                break;
        }
    }
}

void Count_Separate(int count_value)
{
    uint8_t higher_value = 0, lower_value = 0;

    higher_value = (uint8_t)(count_value / 100);
    lower_value = (uint8_t)(count_value % 100);

    print_data[0] = number[higher_value / 10];
    print_data[1] = number[higher_value % 10];
    print_data[2] = number[lower_value / 10];
    print_data[3] = number[lower_value % 10];

    R_FND_Print_Data(print_data);
}


void R_FND_Reset()
{
    /* 7-Segment LED Pin State Initialization */
    R_PORT3->PCNTR1_b.PODR &= ~PODR_DIGIT_MASK & 0xFFFF;
    R_PORT6->PCNTR1_b.PODR |= PODR_PIN_MASK;
}

void R_FND_Print_Data(uint8_t *string)
{
    uint8_t idx = 0;

    if (sizeof(string) != DIGIT_INDEX)
        return;

    for (idx = 0; idx < DIGIT_INDEX; idx++){
        if(string[idx] == 0xC0 && idx == 0 )
            continue;
        if(string[idx] == 0xC0 && idx == 2 )
            continue;
        R_FND_Display_Data(idx, string[idx]);
    }
}

void R_FND_Display_Data(uint8_t digit, uint8_t data)
{

    uint16_t high_nibble = (uint16_t)((data << PODR_INDEX_HIGH) & PODR_HIGH_MASK);
    uint16_t low_nibble = (uint16_t)((data << PODR_INDEX_LOW) & PODR_LOW_MASK);

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    R_FND_Reset();

    /* 7-Segment Digit Selection */
    R_PORT3->PCNTR1_b.PODR = (uint16_t)((0x0010 << (1 + digit)) & PODR_DIGIT_MASK);

    /* 7-Segment LED Pin State Setting */
    R_PORT6->PCNTR1_b.PODR = high_nibble | low_nibble;

}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
